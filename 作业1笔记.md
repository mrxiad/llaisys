# LLAISYS 作业1 笔记（Tensor）

完成时间：2026-02-10

## 1. 目标

根据作业1要求，完成 `src/tensor/tensor.cpp` 中以下函数：

- `load(const void *src)`
- `isContiguous() const`
- `view(const std::vector<size_t> &shape) const`
- `permute(const std::vector<size_t> &order) const`
- `slice(size_t dim, size_t start, size_t end) const`

并通过：

```bash
python test/test_tensor.py
```

## 2. 实现内容

### 2.1 `isContiguous`

实现逻辑：

- 空 shape 视为连续。
- 从最后一维向前检查 stride。
- 对 `shape[i] == 1` 的维度跳过（与 PyTorch contiguous 判定一致性更好）。
- 期望 stride 逐维累乘，若任意维不匹配则返回 `false`。

### 2.2 `permute`

实现逻辑：

- 校验 `order.size() == ndim`。
- 校验每个维度索引合法且不重复。
- 仅重排 `shape`/`strides`，共享原 `storage`，保持 `offset` 不变。
- 不发生数据搬运。

### 2.3 `view`

实现逻辑：

- 校验新形状元素总数与原张量一致。
- 限定仅对连续张量做 view（非连续直接抛错）。
- 按连续内存规则重新生成新 shape 对应的 strides。
- 共享原 `storage`，保持 `offset` 不变。

说明：

- 这样可以避免在非连续内存上错误 reshape（README 里也特别强调该点）。

### 2.4 `slice`

实现逻辑：

- 校验 `dim` 合法。
- 校验 `start <= end <= shape[dim]`。
- 当前不支持负 stride（与测试工具一致）。
- 返回共享存储的新张量：
  - `shape[dim] = end - start`
  - `offset += start * strides[dim] * elementSize`
  - 其他维度 shape/stride 不变

### 2.5 `load`

实现逻辑：

- 校验 `src` 非空。
- 切换当前上下文到目标 tensor 所在设备。
- 按设备类型选择 memcpy kind：
  - CPU tensor: `H2H`
  - 非 CPU tensor: `H2D`
- 使用 runtime API 的 `memcpy_sync` 将主机数据写入 tensor 内存。

## 3. 编译与测试

### 3.1 重新编译安装

执行命令：

```bash
xmake -v
xmake install -v
./.venv310/bin/pip install ./python/
```

说明：

- 仅 `xmake install` 会把新 `.so` 复制到仓库 `python/llaisys/libllaisys/`。
- 当前测试实际 import 的是虚拟环境 site-packages 里的 `llaisys`，所以还需 `pip install ./python/` 同步动态库。

### 3.2 运行作业1测试

执行命令：

```bash
./.venv310/bin/python test/test_tensor.py
```

结果：

- `load / view / permute / slice` 对齐 PyTorch。
- 最终输出：`Test passed!`

## 4. 修改文件

- `src/tensor/tensor.cpp`

## 5. 完成状态

- [x] 任务 1.1 `load`
- [x] 任务 1.2 `isContiguous`
- [x] 任务 1.3 `view`
- [x] 任务 1.4 `permute`
- [x] 任务 1.5 `slice`
- [x] 任务 1.6 测试通过

